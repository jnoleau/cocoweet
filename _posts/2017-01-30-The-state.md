---
layout: post
title: Managing application state in React
author: jnoleau
---

Today the common answer would be "managing the state? --> use Redux, it's obvious"... maybe not :)

I will not criticize Redux in this article, because it is a very good state manager, well documented with a simple Api but **Redux is not simple**. It separates 2 concepts, the Action - *the cause* - and the Reducer - *the consequence* -. This separation could be powerful but is often misunderstood and only creates in most cases a useless "indirection". Please don't use a library because everyone uses it (you should read [this](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) from Redux author). Before even trying to use a library you need to understand which problem it solves, and more importantly **which problem you want to solve**.

To go deeper into state management we're gonna start from React alone and forget every else. Remember your first React Component...

## Props VS State

That's the first question we ask, in a component what's the difference between state and props?

![Test button](/cocoweet/images/article/state_managing/button.gif)

#### With State

<script src="https://gist.github.com/jnoleau/f332c869ba5986127930f6d4c8176854.js"></script>

#### With Props

<script src="https://gist.github.com/jnoleau/0305b5431e0ea84dc3a385cc64cd8898.js"></script>

* Each time the state is changed, the component is re-rendered;
* Each time the props is changed, the component is re-rendered;

From the rendering point of view: it's the same! The render process is just a function transforming state & props `(props, state) => VDOM` .The difference is not based on the renderer but on the component itself, the difference is about **Responsability**.

I have omitted the parent component `<MyButtonContainer />` but in fact it contains the state if `<MyButton />` does not:

<script src="https://gist.github.com/jnoleau/ecb838a4852eaaa8f04d7971eb576ccf.js"></script>

The props are computed on a higher state in the component hierarchy. A stateful component is responsible to manage, to update its private local state.

A simple vision is to consider that props are read-only parameters while state is a private, local set of attributes.

## So where does live the state?

Let's create a very simple application: a month-year selector.

![Month selector 1](/cocoweet/images/article/state_managing/ms_1.png)

I have one component including its state: the current month, but for UI reason I want to add a "prev" and "next" button.

![Month selector 2](/cocoweet/images/article/state_managing/ms_2.png)

Ok I have a problem to solve, I need to refactor my previous component and pull up the state in a parent container. Something like this:

![Month selector 3](/cocoweet/images/article/state_managing/ms_3.png)

Then I want to use this month in another part of my app to display the season associated with this month.

![Month selector 4](/cocoweet/images/article/state_managing/ms_4.png)

I am in front of a recurring problem! Each time I add a feature on my application, I need to refactor my root component and pull up <span style="color:red;">the state</span>.

Another related problem is the <span style="color:purple;">callback props hell</span>. Because I need the state on my top component, others components are not able to manage it, they are all stateless so we need a chain to pull up the user interactions. In this very simple example we have only a 3-levels tree but in a real app you might come up to lengthy chains, let alone the naming `onChange -> onChange -> onChange -> onChange -> ..`.

Here we go, **let's try to solve this problem**

If you focus on the root component you can see it is nothing more than a state manager. It has an attribute, the state, - the *application* state - which is our **Model** and it updates this model on interactions (pulled up by others), like a **Controller**! this is not exactly the role of React (our **View**), so a common idea is to separate this "M.C.".

## Separate the state manager

If I export only the state which is a plain object, nothing will happen because React needs an explicit `setState` to rerender the tree. I need something to turn the state into something observable: **The Store**. Then I have just to implement the Observer pattern with a generic component, listening to this store (this is the component hidden behind the connect function in `react-redux`).

Each time the state changes, the Store notifies its listeners, the `<Connector />` does a `setState` and the magic happens.

![Store](/cocoweet/images/article/state_managing/store.png)

So I come up to a simpler version of Flux: the view connector or anything else in the env calls a function (we can call this function an "Action" but remember this is just a vanilla JS function), this function has direct access to the store Api `setState` and the store notifies its listeners (for example the view) each time the state has been modified.

## Implementation of "Simplux"

The state manager I am describing - let's call it Simplux - is really easy to implement. I could develop it from scratch but let's leverage Redux (I'd rather not reinvent the wheel and lose all the community effort around Redux and all the tools). Redux is in fact more generic than Simplux so a smarter way is to use Redux!

I only need to (re)implement the `setState(state)` function. Here is the idea:

<script src="https://gist.github.com/jnoleau/f425d978f9dac67254dbc2d83577cfff.js"></script>

The microlib can be found on npm `npm i --save redux-simplux` (source: [https://github.com/jnoleau/simplux](https://github.com/jnoleau/simplux) )
